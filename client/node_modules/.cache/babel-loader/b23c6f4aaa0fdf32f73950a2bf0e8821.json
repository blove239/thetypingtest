{"ast":null,"code":"var _jsxFileName = \"/home/brandon/jsproj/thetypingtest/src/Components/Word.js\";\nimport React, { useState, useEffect, createRef, useRef, memo } from 'react';\nimport Char from './Char';\nimport '../css/word.css';\n\nconst Word = ({\n  word,\n  isCurrentWord,\n  userInputWords,\n  currentWordNum,\n  resetTestState,\n  isTestActive\n}) => {\n  const charList = word.split('').map((char, i) => {\n    return {\n      char: char,\n      style: 'default',\n      key: i\n    };\n  });\n  const [chars, setChars] = useState(charList);\n  const scrollRef = createRef();\n  const prevUserInputWordsRef = useRef();\n  const prevCurrentWordNumRef = useRef();\n  useEffect(() => {\n    prevUserInputWordsRef.current = userInputWords[currentWordNum];\n    prevCurrentWordNumRef.current = currentWordNum;\n  }, [userInputWords, currentWordNum]);\n  const prevUserInputWords = prevUserInputWordsRef.current;\n  const prevCurrentWordNum = prevCurrentWordNumRef.current;\n\n  const updateCharStyles = () => {\n    if (userInputWords.length <= word.length && isTestActive) {\n      const newChars = chars.map((charInstance, i) => {\n        const inputChar = userInputWords[i];\n        const newChar = { ...charInstance,\n          style: 'default'\n        };\n\n        if (charInstance.char === inputChar) {\n          newChar.style = 'correctChar';\n        } else if (inputChar && inputChar !== charInstance.char) {\n          newChar.style = 'incorrectChar';\n        }\n\n        return newChar;\n      });\n      setChars(newChars);\n    }\n\n    if (userInputWords[currentWordNum].length >= word.length && prevUserInputWords.length > userInputWords[currentWordNum].length) {\n      setChars(chars => chars.slice(0, -1));\n    } else if (userInputWords[currentWordNum].length > word.length) {\n      setChars(chars => chars.concat({\n        char: userInputWords[currentWordNum].slice(-1),\n        style: 'incorrectChar',\n        key: chars.length\n      }));\n    }\n  };\n\n  useEffect(() => {\n    if (resetTestState) {\n      setChars(charList);\n    }\n\n    if (isCurrentWord) {\n      scrollRef.current.scrollIntoView({\n        behavior: 'smooth',\n        block: 'center'\n      });\n    }\n\n    if (isCurrentWord && prevCurrentWordNum === currentWordNum) {\n      updateCharStyles();\n    }\n  }, [userInputWords, currentWordNum, resetTestState]);\n\n  const renderChar = (key, char, style) => {\n    return /*#__PURE__*/React.createElement(Char, {\n      key: key,\n      style: style,\n      char: char,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 71,\n        columnNumber: 7\n      }\n    });\n  };\n\n  return /*#__PURE__*/React.createElement(\"li\", {\n    ref: scrollRef,\n    className: isCurrentWord ? 'current-word' : 'default',\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 79,\n      columnNumber: 5\n    }\n  }, chars.map(x => renderChar(x.key, x.char, x.style)));\n};\n\nconst areEqual = (prevProps, nextProps) => {\n  if (nextProps.resetTestState) {\n    return false;\n  } else if (nextProps.currentWordNum + 1 === nextProps.index) {\n    return false;\n  } else if (nextProps.currentWordNum === nextProps.index) {\n    return false;\n  } else if (nextProps.currentWordNum - 1 === nextProps.index) {\n    return false;\n  } else {\n    return true;\n  }\n};\n\nexport default memo(Word, areEqual);","map":{"version":3,"sources":["/home/brandon/jsproj/thetypingtest/src/Components/Word.js"],"names":["React","useState","useEffect","createRef","useRef","memo","Char","Word","word","isCurrentWord","userInputWords","currentWordNum","resetTestState","isTestActive","charList","split","map","char","i","style","key","chars","setChars","scrollRef","prevUserInputWordsRef","prevCurrentWordNumRef","current","prevUserInputWords","prevCurrentWordNum","updateCharStyles","length","newChars","charInstance","inputChar","newChar","slice","concat","scrollIntoView","behavior","block","renderChar","x","areEqual","prevProps","nextProps","index"],"mappings":"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","sourcesContent":["import React, { useState, useEffect, createRef, useRef, memo } from 'react';\nimport Char from './Char';\nimport '../css/word.css';\n\nconst Word = ({ word, isCurrentWord, userInputWords, currentWordNum, resetTestState, isTestActive }) => {\n  const charList = word.split('').map((char, i) => {\n    return {\n      char: char,\n      style: 'default',\n      key: i\n    };\n  });\n  const [chars, setChars] = useState(charList);\n  const scrollRef = createRef();\n\n  const prevUserInputWordsRef = useRef();\n  const prevCurrentWordNumRef = useRef();\n  useEffect(() => {\n    prevUserInputWordsRef.current = userInputWords[currentWordNum];\n    prevCurrentWordNumRef.current = currentWordNum;\n  }, [userInputWords, currentWordNum])\n\n  const prevUserInputWords = prevUserInputWordsRef.current;\n  const prevCurrentWordNum = prevCurrentWordNumRef.current;\n\n  const updateCharStyles = () => {\n    if (userInputWords.length <= word.length && isTestActive) {\n      const newChars = chars.map((charInstance, i) => {\n        const inputChar = userInputWords[i];\n        const newChar = {\n          ...charInstance,\n          style: 'default'\n        };\n        if (charInstance.char === inputChar) {\n          newChar.style = 'correctChar'\n        } else if (inputChar && inputChar !== charInstance.char) {\n          newChar.style = 'incorrectChar'\n        }\n        return newChar;\n      })\n      setChars(newChars);\n    } if (userInputWords[currentWordNum].length >= word.length &&\n      (prevUserInputWords.length > userInputWords[currentWordNum].length)) {\n      setChars(chars => chars.slice(0, -1))\n    } else if (userInputWords[currentWordNum].length > word.length) {\n      setChars(chars => chars.concat({\n        char: userInputWords[currentWordNum].slice(-1),\n        style: 'incorrectChar',\n        key: chars.length\n      }))\n    }\n  }\n\n  useEffect(() => {\n    if (resetTestState) {\n      setChars(charList);\n    }\n    if (isCurrentWord) {\n      scrollRef.current.scrollIntoView({\n        behavior: 'smooth',\n        block: 'center',\n      });\n    }\n    if (isCurrentWord && prevCurrentWordNum === currentWordNum) {\n      updateCharStyles();\n    }\n  }, [userInputWords, currentWordNum, resetTestState])\n\n  const renderChar = (key, char, style) => {\n    return (\n      <Char\n        key={key}\n        style={style}\n        char={char}\n      />\n    );\n  };\n  return (\n    <li ref={scrollRef} className={(isCurrentWord) ? 'current-word' : 'default'}>\n      {chars.map(x => renderChar(x.key, x.char, x.style))}\n    </li>\n  );\n};\n\nconst areEqual = (prevProps, nextProps) => {\n  if (nextProps.resetTestState) {\n    return false;\n  }\n  else if (nextProps.currentWordNum + 1 === nextProps.index) {\n    return false;\n  }\n  else if (nextProps.currentWordNum === nextProps.index) {\n    return false;\n  }\n  else if (nextProps.currentWordNum - 1 === nextProps.index) {\n    return false\n  } else {\n    return true;\n  }\n}\n\nexport default memo(Word, areEqual);"]},"metadata":{},"sourceType":"module"}